/**
 * 
 */


import java.util.ArrayList;
import java.sql.*;




/**
 * This class represents a SSQ in the Morpheus system
 * 
 * @author clint
 * 
 */
public class SSQClass {

	public int getSsqId() {
		return ssqId;
	}

	public Constants.SSQType getType() {
		return type;
	}

	public String getRealm() {
		return realm;
	}

	public ArrayList<Term> getInputs() {
		return inputs;
	}

	public ArrayList<Term> getOutputs() {
		return outputs;
	}

	public String getQuery() {
		return query;
	}

	public void setQuery(String query) {
		this.query = query;
	}

	private int ssqId = 0;
	private Constants.SSQType type;
	private String realm = "";
	private String query = "";
	private ArrayList<Term> inputs = new ArrayList<Term>();
	private ArrayList<Term> outputs = new ArrayList<Term>();
	public static ArrayList<String> stopWords = new ArrayList<String>();

	
	public static void loadStopWords(){
		stopWords.add("a");
		stopWords.add("an");
		stopWords.add("the");
		stopWords.add("for");
	}
	
	/**
	 * Constructors
	 */

	/**
	 * For a qualified SSQ i.e. for the SSQs generated by QRR
	 * 
	 * @throws SQLException
	 */
	public SSQClass(int ssqId) throws SQLException {

		this.loadSSQ(ssqId);
		this.type = Constants.SSQType.QUALIFIED;

	}

	/**
	 * For a candidate SSQ i.e. for the SSQs generated by NLP engine
	 */
	public SSQClass(String query) {

		this.setQuery(query);
		this.type = Constants.SSQType.CANDIDATE;
	}

	/**
	 * For a candidate SSQ i.e. for the SSQs generated by NLP engine
	 */
	public SSQClass() {
		this.type = Constants.SSQType.CANDIDATE;
	}

	/*
	public void addInputs(int order, String term, String category) {
		this.inputs.add(new Term(order, term, category));
	}

	public void addInputs(String term, String category) {
		this.inputs.add(new Term(term, category));
	}*/

	/**
	 * Trims the preceding unwanted terms 
	 */
	
	public static String trimPrec(String term){
		String []arry = term.trim().split(" ");
		String trimmedTerm = "";
		boolean flag = false; 
	
		
		for (String t : arry){
			if (!isStopWord(t.trim())){
				flag = true; 
				trimmedTerm += t + " ";					
			}
			else if (flag)
				trimmedTerm += t + " ";						
		}
		
		return trimmedTerm.trim();
	}
	
	
	public void addInputs(String term) {
		
		// TODO: This processing should be done 
		// at the NLP end  
		
		String trimmedTerm = trimPrec(term);
		
		if (trimmedTerm.length() > 0 
				&& !isExists(this.inputs, trimmedTerm))
			this.inputs.add(new Term(trimmedTerm));
		
	}
	
	public static boolean isExists(ArrayList<Term> terms, String term){
		for (Term t : terms)
			if (t.term.equalsIgnoreCase(term))
				return true;
		
		return false; 
	}
	
	public static boolean isStopWord(String w){
		
		if (stopWords.size() == 0)
			loadStopWords();	

		for (String sw : stopWords)
			if (sw.equalsIgnoreCase(w.trim()))
				return true;
		
		return false; 
	}
	
	
	
	
	
	/*
	public void addOutputs(String term, String category) {
		this.inputs.add(new Term(term, category));
	}*/

	public void addOutputs(String term) {

		String trimmedTerm = trimPrec(term);
		
		if (trimmedTerm.length() > 0 
				&& !isExists(this.outputs, trimmedTerm))
			this.outputs.add(new Term(trimmedTerm));
	}

	public int countInputs() {
		return this.inputs.size();
	}

	public int countOutputs() {
		return this.outputs.size();
	}

	public void loadSSQ(int ssqId) throws SQLException {

		String selectSQL = "select Q.queryid, Q.querystring, R.realm, QH.individualid, QH.io, P.phrasestring , C.name "
				+ " from query Q "
				+ " inner join queryhas QH  on QH.queryid = Q.queryid and Q.queryid = "
				+ ssqId
				+ " inner join individual I on I.individualid = QH.individualid"
				+ " inner join phrase P on P.phraseid = I.phraseid"
				+ " left join class C on C.classid = I.classid"
				+ " left join realm R on Q.realmid = R.realmid";

		ResultSet rs = DBAccess.executeSelect(selectSQL);

		while (rs.next()) {

			this.ssqId = rs.getInt("queryid");
			this.type = Constants.SSQType.QUALIFIED;
			this.realm = rs.getString("realm");
			this.query = rs.getString("querystring");

			Term c = new Term(rs.getInt("individualid"), rs
					.getString("phrasestring"), rs.getString("name"));

			String istr = rs.getString("io");
			if (istr.equalsIgnoreCase("input"))
				this.inputs.add(c);
			else
				this.outputs.add(c);

		}

	}

	public String toString() {
		StringBuilder sb = new StringBuilder();

		sb.append(this.type + " SSQ:\n");
		sb.append("query: " + this.query + "\n");
		sb.append("realm: " + this.realm + "\n");
		sb.append("id: " + this.ssqId + "\n");

		sb.append("inputs: \n");
		for (Term t : this.inputs) {
			sb.append("\t" + t.term + ": \n");
			for (Category c : t.getCategories())
				sb.append("\t\t" + c.category + " - " + c.probability + " \n");
		}

		sb.append("outputs: \n");
		for (Term t : this.outputs) {
			sb.append("\t" + t.term + ": \n");
			for (Category c : t.getCategories())
				sb.append("\t\t" + c.category + " - " + c.probability + " \n");
		}

		return sb.toString();
	}
	
	public String toSend() {
		StringBuilder sb = new StringBuilder();

		sb.append(" \"query\": \"" + this.query + "\", ");
		sb.append(" \"realm\": \"" + this.realm + "\", ");
		
		sb.append(" \"ssq\": { ");

		sb.append(" \"inputs\": [ ");
		for (Term t : this.inputs) {
			sb.append("{ \"" + t.term + "\": [ ");
			for (Category c : t.getCategories()){
				sb.append("[\"" + c.category + "\", " + c.probability + "],");
			}
			if(t.getCategories().size() > 0){ // Need to remove the trailing comma
				sb.deleteCharAt(sb.lastIndexOf(","));
			}
			sb.append(" ] }, ");
		}
		if(this.inputs.size() > 0){
			sb.deleteCharAt(sb.lastIndexOf(","));
		}
		sb.append("], ");

		sb.append(" \"outputs\": [ ");
		for (Term t : this.outputs) {			
			sb.append("{ \"" + t.term + "\": [ ");
			for (Category c : t.getCategories()){
				sb.append("[\"" + c.category + "\", " + c.probability + "],");
			}
			if(t.getCategories().size() > 0){ // Need to remove the trailing comma
				sb.deleteCharAt(sb.lastIndexOf(","));
			}
			sb.append(" ] }, ");
		}		
		if(this.outputs.size() > 0){
			sb.deleteCharAt(sb.lastIndexOf(","));
		}
		sb.append("] }, ");

		return sb.toString();
	}

}
